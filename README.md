# Анализ и эксплуатация уязвимостей в .com файле

## Введение

Мне был предоставлен .com файл, который представлял собой простую программу для проверки пароля. Пользователь должен был ввести пароль, и если он был правильным, программа выводила соответствующее сообщение. В противном случае выводилось сообщение о том, что пароль неправильный.
#### 1 часть задачи состояла в том, чтобы проанализировать программу с помощью дизассемблера и отладчика, найти уязвимости и, используя их, заставить программу вывести сообщение о том, что введённый пароль верный.
#### 2 часть задачи заключалась в том, чтобы написать программу с графическим интерфейсом, которая бы меняла байты в предоставленной программе, таким образом, чтобы она выводила сообщение о правильности ввода пароля при вводе неправильного пароля.

## 1 часть задачи. Анализ программы

### Исходные данные

Программа представляла собой исполняемый файл с расширением .com, который работал в среде DOS. Для анализа использовались следующие инструменты:

- **Дизассемблер (Radare2)**: Для анализа машинного кода и получения ассемблерного листинга.


![Screenshot from 2025-03-03 23-47-02](https://github.com/user-attachments/assets/226a4fa8-d49c-43fc-81c1-e7e57dbafe5d)


- **Отладчик (TurboDebugger)**: Для пошагового выполнения программы и анализа состояния регистров и памяти.


![Снимок экрана 2025-03-03 205632](https://github.com/user-attachments/assets/33aaa6ca-a1c1-4463-aa2e-831d7353e0ec)


### Основная логика программы

Программа выполняла следующие шаги:

1. Запрашивала у пользователя ввод пароля.
2. Считала хэш введённого пароля.
3. Сравнивала введенный пароль с "эталонным" хэшем, хранящимся в памяти.
4. Если пароль совпадал с хэшем, выводилось сообщение о том, что пароль верный.
5. Если пароль не совпадал, выводилось сообщение о том, что пароль неверный.

## Обнаруженные уязвимости

В процессе анализа были обнаружены две уязвимости, связанные с переполнением буфера.

### Уязвимость 1: Переполнение буфера для изменения эталонного хэша

Первая уязвимость заключалась в том, что программа не проверяла длину вводимого пароля. Это позволяло переполнить буфер, в котором хранился введенный пароль, и изменить значение эталонного хэша, с которым сравнивался пароль.

**Шаги эксплуатации:**


1. Создание файла со строкой, в которой содержалась строка, утроенная следующим образом: В начале строки был расположен неправильный пароль. После него в строке были расположены байты программы, находящиеся между буфером для вводимого пароля и "эталонным хэшем". Эта часть строки необходима для правильного выполнения программы. Далее был расположен заранее рассчитанный хэш неправильного пароля.
2. Запуск программы с перенаправленным вводом из подготовленного файла.

В результате программа выводила сообщение о том, что пароль верный, даже если введенный пароль изначально был неправильным.

### Уязвимость 2: Переполнение буфера для изменения кода возврата

Вторая уязвимость также была связана с переполнением буфера. Однако в этом случае целью было изменить адрес возврата в стеке, чтобы перенаправить выполнение программы на участок памяти, где был размещен собственный код.

**Шаги эксплуатации:**

1. Создание файла со строкой, в которой содержалась строка, утроенная следующим образом: В начале строки был расположен терминальный символ -- символ, по которому программа где заканчивается пароль в строке, введённой пользователем. В данной программе терминальным символом являлся "символ переноса каретки" с ASCII-кодом 0x0d. Далее был расположен код программы, находящийся после буфера для пароля и нулевые байты после конца программы. В конце строки находился программный код (•), который выводил правильное сообщение. Последним байтом строки являлся адрес начала программного кода (•). Этот байт при записи во время выполнения программы заменял собой код возврата из функции, в которой запрашивался ввод пароля.
2. Запуск программы с перенаправленным вводом из подготовленного файла.

После выполнения этих шагов программа передавала управление на "чужой" код, который выводил сообщение о том, что пароль верный, независимо от введенного значения.

## 2 часть задачи.

### Создание программы с графическим интерфейсом, взламывающей предложенный файл.

Данная программа была реализована на языке С с использованием библиотеки SFML для графического интерфейса.
Программа состоит из меню, содержащего окно с развлекающей анимацей, поля для ввода имени файла, кнопки запуски кряка.
Программа меняет байтовое представление команды je (0x74) на jne (0x75), которая проверяет равен ли хэш вводимого пароля хэшу правильного пароля. Таким обращом программа будет выдавать сообщение о том, что введённый пароль верный, если он не является таковым.

## Заключение

В результате анализа программы были обнаружены и успешно эксплуатированы две уязвимости, связанные с переполнением буфера. Эти уязвимости позволили обойти проверку пароля и добиться желаемого поведения программы. Данный пример демонстрирует важность проверки входных данных и использования безопасных методов программирования для предотвращения подобных атак.

