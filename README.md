# Анализ и эксплуатация уязвимостей в .com файле

## Введение

Мне был предоставлен .com файл, который представлял собой простую программу для проверки пароля.
Пользователь должен был ввести пароль, и если он был правильным, программа выводила соответствующее сообщение.
В противном случае выводилось сообщение о том, что пароль неправильный.

### 1 часть задачи
состояла в том, чтобы проанализировать программу с помощью дизассемблера и отладчика, найти уязвимости и, используя их,
заставить программу вывести сообщение о том, что введённый пароль верный.

### 2 часть задачи
заключалась в том, чтобы написать программу с графическим интерфейсом, которая бы меняла байты в предоставленной программе,
таким образом, чтобы программа выводила сообщение о правильности ввода пароля при вводе неправильного пароля.

## 1 часть задачи. Анализ и взлом программы

### Исходные данные

Программа представляла собой исполняемый файл с расширением .com, который работал в среде DOS.
Для анализа и взлома использовались следующие инструменты:

- **Дизассемблер (IDA)**: Для анализа машинного кода и получения ассемблерного листинга.
- **Отладчик (TurboDebugger)**: Для пошагового выполнения программы и анализа состояния регистров и памяти.
- **Hex-редактор (Hex editor Microsoft)**: для создания файлов для взлома программы.

### Анализ программы с помощью дизассемблера IDA

Первым делом был произведён поиск строк в исходном файле crackme.com.

К сожалению воспользоваться встроенными методами IDA, а именно представление файла в виде Strings, не удалось.
IDA считала, что в файле нет никаких строк. Скорее всего это произошло по причине того, что представление строки
в DOS и в Windows (ОС, на которой была запущена IDA) отличаются.

Для того, чтобы увидеть какие строки есть в программе, были использованы комментарии, которые вставляет IDA в view-режиме "Disassembly"
после строк с объявлением байтов (db).

![Снимок экрана 2025-03-05 214921](https://github.com/user-attachments/assets/1e1984f7-3096-4ca8-b2ea-6e12d9701a8c)

Был обнаружен адрес сообщения о правильности введённого пароля. Т.к. в DOS адреса смещаются на 100
из-за Programm Segment Prefix (PSP), следует прибавить 100 к обнаруженному адресу, для дальнейшего поиска его в ассемблерном коде.
Итак, адрес "правильного" сообщения — 0DDh + 100h = 1DDh.

Далее, с помощью "Search -> Immediate value" была найдена функция использующая данный адрес.

![Снимок экрана 2025-03-05 215746](https://github.com/user-attachments/assets/d3c15106-ebff-4440-b7f7-05cfa5ffde50)

Как видно из комментарий, вставленных IDA. Функция sub_6F выводит сообщение о том что введённый пароль верный. Для
взлома программы необходимо проанализировать, при каких обстоятельствах вызывается данная функция.

С помощью "View -> Graphs -> Xrefs to" получаем наглядный граф того какие функции вызываются перед sub_6F

![Снимок экрана 2025-03-05 215945](https://github.com/user-attachments/assets/42f78f8a-2e03-419c-8918-bb15f2c7b5aa)

Анализируем функцию sub_13

![Снимок экрана 2025-03-05 220226](https://github.com/user-attachments/assets/9fcee868-7c5c-4612-b4b7-9feab2e27a56)

Как видно из графа после вызова функции sub_28 сравнивается значение регистра BX и значение слова в памяти по адресу
1EE. Уже отсюда можно сделать вывод, что способ определения правильности введённого пароля — хэширование, правильный хэш
лежит по адресу 1EE. Если BX равен правильному хэшу, вызывается функция sub_6F, выводящая сообщение о правильности введённого
пароля, функция sub_77 выводит сообщение о том, что пароль неверный.

Посмотрим теперь, что происходит в функции sub_28

![Снимок экрана 2025-03-05 221002](https://github.com/user-attachments/assets/c03db504-8b3b-42ff-8b1a-bc2f99112465)

До вызова функции sub_3B на экран выводится строка по адресу 1B5h. Посмотрим, интереса ради, что она содержит.
Для этого необходимо предварительно вычесть из 1B5h 100h, чтобы учесть PSP. По адресу 0B5h в файле crackme.com лежит строка
"Enter your password pls".

![Снимок экрана 2025-03-05 221450](https://github.com/user-attachments/assets/9d977129-06a0-439e-b403-9ebe327eb5d2)

Можно сделать предположение, что в функции sub_3B реализован ввод пароля пользователем. Проверим это

![Снимок экрана 2025-03-05 221747](https://github.com/user-attachments/assets/6724fd9e-7c79-4f51-9b7b-876b583054d0)

Согласно комментариям, вставленным IDA, предположение подтвердилось. Причём ввод реализован из файла. То есть при желании можно
перенаправить ввод в консоль из другого файла (запомним это). Ещё одна интересная особенность заключается в том, что размер
буфера для ввода очень большой — 0ffffh - 01abh. При этом адрес буфера для ввода - 01abh (dx := 01abh в функции sub_28).
То есть переполнением буфера можно затереть практически весь сегмент, за исключением части находящейся перед буфером.

И вот мы нашли первую уязвимость: адрес правильного хэша — 1EEh находится после буфера для ввода. Т.е. мы можем записать
туда собственное значение, которое соответствует введённому нами паролю. Таким образом, программа посчитает, что пароль верный и
выведет искомое сообщение.

Остаётся понять хэш чего считает программа — пароля или всего буфера. После ввода пароля программа делает нечто с регистром CX.
Она смотрит первое вхождения символа с ASCII-кодом 0Dh — перенос каретки — и кладёт в CX количество символов от начала буфера
до этого символа.

Можно сделать предположение, что в дальнейшем программа считает хэш именно этой части буфера.

Анализируем программу дальше. В функции sub_28 после вызова функции sub_3B идёт вызов функции sub_56.

![Снимок экрана 2025-03-05 223544](https://github.com/user-attachments/assets/90a486d2-2c8a-4253-b7aa-78fc1441caf2)

Ура! Все наши предположения верны. Программа действительно считает хэш введённого пароля вплоть до символа переноса каретки.
Функция sub_56 считает djb2 хэш строки начинающейся по адресу 1ABh длиной CX символов.

Итак, одна уязвимость найдена. Не так ли?

На самом деле мы уже нашли вторую уязвимость. Т.к. длина буфера позволяет нам менять почти весь сегмент, в том числе и стек программы,
который находится в конце сегмента, мы можем делать что хотим. Переполнив буфер настолько, что мы сможем поменять адрес возврата из
функции sub_3B (ввод пароля пользователем), мы можем заставить исполняться сторонний код, который сами и напишем.

### Взлом программы

Итак, нам нужно написать 2 файла, которые содержат в себе последовательности байтов, которые при попадании в буфер для ввода пароля
позволят нам добиться желаемого результата.

#### 1 уязвимость

Для начала выберем любой пароль и посчитаем для него djb2 хэш.
Запустим crackme.com в TurboDebugger, чтобы проверить на практике наш метод. Поставим breakpoint сразу после вызова
прерывания для чтения в буфер из файла в функции по адресу 3Bh (sub_3B в IDA), поменяем в памяти программы значение,
 лежащее по адресу 01EEh.

![Снимок экрана 2025-03-05 225837](https://github.com/user-attachments/assets/341cfb90-ecd4-47b8-8b56-f50bbeda5087)

После окончания работы программы на экране действительно появилось сообщение о том, что пароль верный. Теперь мы готовы к
написанию файла, который взломает программу.
С помощью Hex-editor Microsoft откроем crackme.com и скопируем оттуда часть файла, лежащую от адреса ABh до адреса EEh.
Вставим содержимое в пустой файл и поменяем последние два байта на рассчитанный хэш. Поменяем первые байты в файле на
выбранный пароль и байт 0Dh, чтобы программа посчитала хэш именно пароля.

Запустим программу crackme.com и перенаправим ввод в консоль из нашего файла.

Программа взломана. Выводится сообщение о том, что введённый пароль верный.

#### 2 уязвимость

Для начала нужно понять куда именно класть адрес возврата. С этим нам опять поможет TurboDebugger. Запустим crackme.com,
поставим breakpoint сразу после вызова прерывания для чтения в буфер из файла в функции по адресу 3Bh (sub_3B в IDA).
Посмотрим текущее значение SP.

![Снимок экрана 2025-03-05 231306](https://github.com/user-attachments/assets/1c147063-dd1f-4ead-85a6-e689e54e899b)

SP = 0FFF8h.

Создадим с помощью кода на Python файл размером 0FFFFh - 1ABh - 6h байт, состоящий, из нулевых байтов.
"0FFFFh - 1ABh" — это размер вводимого буфера. Вычитание 6 байт нужно, потому что мы меняем только значение, находящееся
по адресу 0FFF8h, то есть байты с 0FFFAh по 0FFFFh (всего 6 байт) мы не трогаем.

```
with open('file', 'wb') as f:
    f.write(b'\x00' * 64 * 1024)
```

Откроем crackme.com в hex-редакторе и скопируем всё, что находится после начала буфера для ввода пароля.
Вставим содержимое в наш файл. В последние два байта файла мы запишем адрес в памяти, по которому будет лежать
"наша" функция. Значение не особо важно, главное чтобы код "нашей" функции не затирал данные программы и новый
код возврата.

Теперь напишем код, который будет исполняться при возврате из функции sub_3B. Он будет состоять из вывода строки
по адресу 1DDh (сообщение о том, что введённый пароль - правильный)

```
    mov     ah, 9
    mov     dx, 1DDh
    int     21h
```

изменения значения sp, так чтобы он указывал на адрес возврата в самую первую функцию, чтобы программа передала
управление операционной системе: sp += 4 - пропуск двух адресов возврата

```
    inc sp
    inc sp
    inc sp
    inc sp
```

 и собственно возврата по этому адресу ``` ret ```

![Снимок экрана 2025-03-05 234158](https://github.com/user-attachments/assets/7cd4f5a0-0982-4017-96d5-e498181c5ebe)

Запустим программу crackme.com и перенаправим ввод в консоль из нашего файла.

Программа взломана. Выводится сообщение о том, что введённый пароль верный.

## 2 часть задачи.

### Создание программы с графическим интерфейсом, взламывающей предложенный файл.

Данная программа была реализована на языке С с использованием библиотеки SFML для графического интерфейса.
Программа состоит из меню, содержащего окно с развлекающей анимацей, поля для ввода имени файла, кнопки запуски кряка.
Программа меняет байтовое представление команды je (0x74) на jne (0x75), которая проверяет равен
ли хэш вводимого пароля хэшу правильного пароля.
Таким обращом программа будет выдавать сообщение о том, что введённый пароль верный, если он не является таковым.

## Заключение

В результате анализа программы были обнаружены и успешно эксплуатированы две уязвимости, связанные с переполнением буфера. Эти уязвимости позволили обойти проверку пароля и добиться желаемого поведения программы. Данный пример демонстрирует важность проверки входных данных и использования безопасных методов программирования для предотвращения подобных атак.

